user nginx nginx;

error_log logs/error.log;
#error_log logs/error.log notice;
#error_log logs/error.log info;

pid logs/nginx.pid;

# Устанавливать значение по количеству ядер процессора. 
# cat /proc/cpuinfo | grep processor
worker_processes 2;

events {
	use epoll;
	# Директива определяет какое максимальное количество клиентов может обработать один процесс.
	# Можно посчитать какое максимальное количество клиентов может принять Nginx.
	# максимальное количество клиентов = worker_connections * worker_processes
	# Пример: 2048 = 1024 * 2
	worker_connections 1024;
}



# Максимально допустимое количество открываемых файлов для Nginx, формула расчёта:
# максимальное число открытых файлов = максимальное количество клиентов * 2
# Пример: 4096 = 2048 * 2
# Множитель 2 получен из расчёта, так как необходимо 2 файловых дескриптора на каждое подключение:
# Один дескриптор для входящего подключения и второй для исходящего (выдаваемого) файла (или потока, upstream, proxy).
# Важно, чтобы в Linux максимальное количество открываемых файлов было намного больше того, что задано в Nginx.
# Просмотреть открытые файлы в Linux можно с помощью команды "lsof".
# Просмотреть допустимое максимальное число открытых файлов в Linux можно с помощью команды "ulimit -a" пункт "open files".
# Изменить в Linux опцию "open files" можно с помощью команды "ulimit -n 200000" или через редактор "/etc/security/limits.conf".
worker_rlimit_nofile 4096;


# Настройки для всех хостов.
http {

	# Запретить Nginx показывать свою версию в HTTP-ответах. Повышает безопасность.
	server_tokens off;
	
	# Разрешает или запрещает вывод листинга каталога. Повышает безопасность.
	autoindex off;
	
	
	include mime.types;
	
	default_type application/octet-stream;

	# Формат одной записи лога.
	log_format main '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent" "$http_x_forwarded_for"';

	access_log logs/access.log main;
	
	sendfile on;
	
	tcp_nopush on;
	
	tcp_nodelay on; 


	# Number of requests a client can make over the keep-alive connection. This is set high for testing.
	keepalive_requests 100000;

	# allow the server to close the connection after a client stops responding. Frees up socket-associated memory.
	reset_timedout_connection on;


	# Максимальный размер данных передаваемых за один запрос.
	# К примеру это означает, что данные передаваемые в POST запросе и загружаемый файл в сумме не может быть больше client_max_body_size.
	client_max_body_size 1024M;

	# Размер буфера для чтения тела запроса клиента.
	# Если тело запроса больше заданного буфера, то всё тело запроса или только его часть записывается во временный файл.
	# Пример: Файл/данные размером 1048576 Мб будут прочитаны из входящего потока за 1048576 / ( 512 * 1024 ) = 2 цикла.
	client_body_buffer_size 512k;


	gzip on;
	gzip_min_length 10240;
	gzip_proxied expired no-cache no-store private auth;
	gzip_types text/plain text/css text/xml text/javascript application/x-javascript application/xml;
	gzip_disable "MSIE [1-6]\.";


	#
	# BEGIN Лимиты времени (таймауты).
	#

	# Задаёт таймаут при чтении заголовка запроса клиента.
	client_header_timeout 1800;

	# Задаёт таймаут при чтении тела запроса клиента.
	# send the client a "request timed out" if the body is not loaded by this time. Default 60.
	client_body_timeout 1800;

	# Задаёт таймаут при передаче ответа клиенту.
	# If the client stops reading data, free up the stale client connection after this much time. Default 60.
	send_timeout 1800;

	# Задаёт таймаут, в течение которого keep-alive соединение с клиентом не будет закрыто со стороны сервера
	# Timeout for keep-alive connections. Server will close connections after this time.
	keepalive_timeout 1800;

	# Задаёт таймаут при передаче запроса FastCGI-серверу. Таймаут устанавливается не на всю передачу запроса, а только 
	# между двумя операциями записи. Если по истечении этого времени FastCGI-сервер не примет новых данных, соединение закрывается. 
	fastcgi_send_timeout 1800;
	
	# Задаёт таймаут при чтении ответа FastCGI-сервера. Таймаут устанавливается не на всю передачу ответа, а только
	# между двумя операциями чтения. Если по истечении этого времени FastCGI-сервер ничего не передаст, соединение закрывается. 
	fastcgi_read_timeout 1800;
	
	# Задаёт таймаут для установления соединения с FastCGI-сервером.
	fastcgi_connect_timeout 1800;

	proxy_connect_timeout 1800;
	
	proxy_send_timeout 1800;
	
	proxy_read_timeout 1800;


	#
	# END Лимиты времени (таймауты).
	#




	# В случае ошибки "upstream sent too big header"
	proxy_buffer_size 128k;
	proxy_buffers 4 256k;
	proxy_busy_buffers_size 256k;

	fastcgi_buffers 512 32k;
	fastcgi_buffer_size 128k;
	fastcgi_busy_buffers_size 128k;
	fastcgi_temp_file_write_size 256k;
	fastcgi_max_temp_file_size 0;
	fastcgi_intercept_errors on;


#	pagespeed off;
#	pagespeed FileCachePath "/var/cache/nginx_pagespeed/";
#	pagespeed EnableFilters combine_css,combine_javascript,rewrite_images,rewrite_css,rewrite_javascript,inline_images,recompress_jpeg,recompress_png,resize_images;
#	pagespeed JpegRecompressionQuality 85;
#	pagespeed ImageRecompressionQuality 85;
#	pagespeed ImageInlineMaxBytes 2048;
#	pagespeed LowercaseHtmlNames on;


	# Конфигурация хоста по умолчанию, то есть того, который на IP.
	include "vhosts/default";
	
	include "vhosts/*.conf";

}



#rtmp {

#	server {

#		listen 1935;

#		application videos {
		#live on;
#			on_play http://stream.site.ru/index.php;
#			play /var/www/stream;
#		}

#	}

#}